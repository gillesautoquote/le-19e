import { Vector2, PlaneGeometry, BufferGeometry, Float32BufferAttribute } from 'three';
import { getTerrainHeight } from '@/systems/terrainSystem';
import type { SceneWater, SceneRoad } from '@/types/osm';

// ─── Waterway geometry ───────────────────────────────────────────

export interface WaterwayGeometryResult {
  geometry: BufferGeometry;
  id: string;
  center: [number, number];
}

/**
 * Create a flat ribbon geometry for a waterway from its centerline points.
 * The ribbon is generated by offsetting each segment perpendicular to its direction.
 */
export function waterwayToGeometry(waterway: SceneWater): WaterwayGeometryResult {
  const pts = waterway.points;
  const halfWidth = waterway.width / 2;

  if (pts.length < 2) {
    const plane = new PlaneGeometry(waterway.width, waterway.width);
    plane.rotateX(-Math.PI / 2);
    return {
      geometry: plane,
      id: waterway.id,
      center: pts[0] ?? [0, 0],
    };
  }

  const leftSide: Vector2[] = [];
  const rightSide: Vector2[] = [];

  for (let i = 0; i < pts.length; i++) {
    let dx = 0;
    let dz = 0;

    if (i === 0) {
      dx = pts[1][0] - pts[0][0];
      dz = pts[1][1] - pts[0][1];
    } else if (i === pts.length - 1) {
      dx = pts[i][0] - pts[i - 1][0];
      dz = pts[i][1] - pts[i - 1][1];
    } else {
      // Normalize each segment before averaging to avoid length bias
      const fx = pts[i + 1][0] - pts[i][0];
      const fz = pts[i + 1][1] - pts[i][1];
      const fl = Math.sqrt(fx * fx + fz * fz);
      const bx = pts[i][0] - pts[i - 1][0];
      const bz = pts[i][1] - pts[i - 1][1];
      const bl = Math.sqrt(bx * bx + bz * bz);
      if (fl > 0.001) { dx += fx / fl; dz += fz / fl; }
      if (bl > 0.001) { dx += bx / bl; dz += bz / bl; }
    }

    const len = Math.sqrt(dx * dx + dz * dz);
    if (len === 0) continue;

    // Perpendicular normal
    const nx = -dz / len;
    const nz = dx / len;

    leftSide.push(new Vector2(pts[i][0] + nx * halfWidth, pts[i][1] + nz * halfWidth));
    rightSide.push(new Vector2(pts[i][0] - nx * halfWidth, pts[i][1] - nz * halfWidth));
  }

  // Build triangle strip as indexed buffer geometry
  const vertices: number[] = [];
  const indices: number[] = [];

  for (let i = 0; i < leftSide.length; i++) {
    // Left vertex
    vertices.push(leftSide[i].x, 0, leftSide[i].y);
    // Right vertex
    vertices.push(rightSide[i].x, 0, rightSide[i].y);

    if (i < leftSide.length - 1) {
      const base = i * 2;
      indices.push(base, base + 1, base + 2);
      indices.push(base + 1, base + 3, base + 2);
    }
  }

  const geometry = new BufferGeometry();
  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  // Center point
  const midIdx = Math.floor(pts.length / 2);
  const center: [number, number] = [pts[midIdx][0], pts[midIdx][1]];

  return { geometry, id: waterway.id, center };
}

// ─── Road geometry ───────────────────────────────────────────────

export interface RoadGeometryResult {
  geometry: BufferGeometry;
  id: string;
  type: SceneRoad['type'];
}

/** Max distance between road ribbon vertices (meters). Keeps ribbon on terrain. */
const ROAD_SUBDIVIDE = 10;

/** Y offset above terrain for road ribbons (just above surface). */
const ROAD_Y_OFFSET = 0.05;

/**
 * Subdivide road polyline so no segment exceeds ROAD_SUBDIVIDE meters.
 * This ensures the ribbon follows terrain height at heightmap resolution.
 */
function subdividePolyline(pts: [number, number][]): [number, number][] {
  const out: [number, number][] = [pts[0]];
  for (let i = 1; i < pts.length; i++) {
    const [ax, az] = pts[i - 1];
    const [bx, bz] = pts[i];
    const dx = bx - ax;
    const dz = bz - az;
    const len = Math.sqrt(dx * dx + dz * dz);
    const steps = Math.ceil(len / ROAD_SUBDIVIDE);
    for (let s = 1; s <= steps; s++) {
      const t = s / steps;
      out.push([ax + dx * t, az + dz * t]);
    }
  }
  return out;
}

/**
 * Create a flat ribbon geometry for a road, same technique as waterway.
 * Road is subdivided so vertices follow terrain heightmap closely.
 */
export function roadToGeometry(road: SceneRoad): RoadGeometryResult {
  const rawPts = road.points;
  const halfWidth = road.width / 2;

  if (rawPts.length < 2) {
    const plane = new PlaneGeometry(road.width, road.width);
    plane.rotateX(-Math.PI / 2);
    return { geometry: plane, id: road.id, type: road.type };
  }

  const pts = subdividePolyline(rawPts);

  const leftSide: Vector2[] = [];
  const rightSide: Vector2[] = [];

  for (let i = 0; i < pts.length; i++) {
    let dx = 0;
    let dz = 0;

    if (i === 0) {
      dx = pts[1][0] - pts[0][0];
      dz = pts[1][1] - pts[0][1];
    } else if (i === pts.length - 1) {
      dx = pts[i][0] - pts[i - 1][0];
      dz = pts[i][1] - pts[i - 1][1];
    } else {
      const fx = pts[i + 1][0] - pts[i][0];
      const fz = pts[i + 1][1] - pts[i][1];
      const fl = Math.sqrt(fx * fx + fz * fz);
      const bx = pts[i][0] - pts[i - 1][0];
      const bz = pts[i][1] - pts[i - 1][1];
      const bl = Math.sqrt(bx * bx + bz * bz);
      if (fl > 0.001) { dx += fx / fl; dz += fz / fl; }
      if (bl > 0.001) { dx += bx / bl; dz += bz / bl; }
    }

    const len = Math.sqrt(dx * dx + dz * dz);
    if (len === 0) continue;

    const nx = -dz / len;
    const nz = dx / len;

    leftSide.push(new Vector2(pts[i][0] + nx * halfWidth, pts[i][1] + nz * halfWidth));
    rightSide.push(new Vector2(pts[i][0] - nx * halfWidth, pts[i][1] - nz * halfWidth));
  }

  const vertices: number[] = [];
  const vertIndices: number[] = [];

  for (let i = 0; i < leftSide.length; i++) {
    const lx = leftSide[i].x;
    const lz = leftSide[i].y;
    const rx = rightSide[i].x;
    const rz = rightSide[i].y;
    vertices.push(lx, getTerrainHeight(lx, lz) + ROAD_Y_OFFSET, lz);
    vertices.push(rx, getTerrainHeight(rx, rz) + ROAD_Y_OFFSET, rz);

    if (i < leftSide.length - 1) {
      const base = i * 2;
      vertIndices.push(base, base + 1, base + 2);
      vertIndices.push(base + 1, base + 3, base + 2);
    }
  }

  const geometry = new BufferGeometry();
  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.setIndex(vertIndices);
  geometry.computeVertexNormals();

  return { geometry, id: road.id, type: road.type };
}
